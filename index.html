<!DOCTYPE html>
<html>
<head>
	
	<title>Bikemap</title>
  <base target="_blank"/>
	<meta charset="utf-8" />
	<meta name="viewport">
	<meta name="theme-color" content="#2196F3">
	<meta name="description" content="Interactive map of cycling routes across British Columbia">
	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
 
    <!-- CSS -->
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="css/leaflet.css"/>
    <link rel="stylesheet" href="css/font-awesome.css">
    <link rel="stylesheet" href="https://unpkg.com/@raruto/leaflet-elevation@2.1.0/dist/leaflet-elevation.min.css" />
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
    <link rel="stylesheet" href="src/leaflet.legend.css" />
    <link rel="stylesheet" href="css/leaflet-sidebar.css" />
    <link rel="stylesheet" href="css/main.css" />
    <link rel="stylesheet" href="css/L.Control.Locate.css" />
    

    <!-- JS-->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script type="text/javascript" src="leaflet-gpx.js"></script>
    <script type="text/javascript" src="src/leaflet-elevation.js"></script>
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/d3@7.6.1/dist/d3.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script type="text/javascript" src="src/leaflet.legend.js"></script>
    <script type="text/javascript" src="src/leaflet-sidebar.js"></script>
    <script type="text/javascript" src="theme.js"></script>
    <script type="text/javascript" src="https://unpkg.com/showdown/dist/showdown.min.js"></script>
    <script src="src/leaflet.edgebuffer.js"></script>
    
    <script src="src/L.Control.Locate.js" charset="utf-8"></script>
    <script type="text/javascript" src="src/leaflet.permalink.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <script src="src/leaflet-offline-bundle.js"></script>
    <script src="src/SmoothWheelZoom.js"></script>

    <!-- Assets -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

</head>

<div id="disclaimer-overlay">
  <div id="disclaimer-box">
    <h3>Safety Disclaimer</h3><br>
    <p>Adventuring outdoors is inherently risky, please spend time to better understand the safety implications associated with these kinds of activies. This should include First Aid and wilderness safety courses. Below are links to some guides to get you started.</p>
    <br>
    <a href="https://insidious-breakfast-586.notion.site/Bikepacking-Safety-1fc4ce7654d94268b0ac3fd3b8a183ae" target="_blank" class="button">General Safety</a>
    <a href="https://www.backroadsbiketouring.com/faq-what-about-logging" target="_blank" class="button">Logging Roads</a>
    <br>
    <p>By clicking "I Understand" you accept all of the information and resources available on this site "as is" and acknowledge the information may include errors and inaccuracies.</p><br>
    <div > 

      <input type="button" class="button" value="I Understand" onclick="document.getElementById('disclaimer-overlay').style.display = 'none';localStorage.setItem('popState','shown')">

      

    </div>

  </div>

</div>    

<!-- Offline Mode Indicator -->
<div id="offline-indicator" style="
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #ff9800;
  color: white;
  padding: 12px 20px;
  text-align: center;
  font-weight: bold;
  z-index: 9999;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
">
  ðŸ”´ OFFLINE MODE - You're not connected to the internet. Showing cached data.
</div>

<div id="map"></div>


<div id="sidebar" class="leaflet-sidebar collapsed">
  <!-- Nav tabs -->
  <div class="leaflet-sidebar-tabs">
      <ul role="tablist"> <!-- top aligned tabs -->
        <li><a href="#sidebar-info" role="tab"><i class="fa fa-info-circle"></i></a></li>
        <li><a href="#sidebar-poi" role="tab"><i class="fa fa-th-list"></i></a></li>
        <li><a href="#sidebar-offline" role="tab"><i class="fa fa-cloud-download"></i></a></li>
        <li style="display:none;"><a href="#routes" role="tab"><i class="fa fa-map"></i></a></li>
 
      </ul>

      <ul role="tablist"> <!-- bottom aligned tabs -->
          <li><a href="#info" role="tab"><i class="fa fa-question-circle-o"></i></a></li>
          
      </ul>
  </div>

  <!-- Tab panes -->
  <div class="leaflet-sidebar-content">
    <div class="leaflet-sidebar-pane" id="sidebar-info">
      <div id="sidebar-content"><h4>Info Panel</h4><p>Please select a route to load details.</p></div>
      <div id="sidebar-info-description"></div><br>
      <hr style="width:92%;margin-left:4%;"><br>
      <div class="elevation" id="elevation-div"></div>
      <div id="data-summary" class="data-summary">
        <div class="data-row">
          <span class="totlen">
            <span class="summarylabel">Length: </span>
            <span class="summaryvalue">0</span>
          </span><br><br>
          <span class="maxele">
            <span class="summarylabel">Max Elevation: </span>
            <span class="summaryvalue">0</span>
          </span><br>
          <span class="minele">
            <span class="summarylabel">Min Elevation: </span>
            <span class="summaryvalue">0</span>
          </span>  
        </div>
        <div class="data-row">
          <span class="gain">
            <span class="summarylabel">Gain: </span>
            <span class="summaryvalue">0</span>
          </span><br>
          <span class="loss">
            <span class="summarylabel">Loss: </span>
            <span class="summaryvalue">0</span>
          </span>
        </div> 
      </div><br>
      <hr style="width:92%;margin-left:4%;"><br>
    </div>

    <div class="leaflet-sidebar-pane" id="sidebar-poi">
      <h4>Overlays</h4>
      <br>
      <div>        <label class="switch">
        <p>Recreation Sites BC</p>
        <input type="checkbox" id="bcrec" onclick="layerControl('bcrec')">
        <span class="slider round"></span>
      </label></div>
      <div style="display:none;">
        <label class="switch">
        <p>Food & Supplies</p>
        <input type="checkbox" id="food" onclick="layerControl('food')" ">
        <span class="slider round"></span>
        </label>
      </div>
      <h4>Routes</h4>
      <a href="routes/t2s/index.html"> Tree to Sea 2022 </a>
    </div>

    <div class="leaflet-sidebar-pane" id="sidebar-offline">
        <h4>Offline Mode</h4>
        <p>Download map tiles and routes to use Bikemap offline. The app will work without internet once cached.</p>
        
        <div id="service-worker-status" style="margin: 15px 0; padding: 10px; background: #e3f2fd; border-radius: 4px;">
          <p style="color: #000;"><strong>Service Worker Status:</strong> <span id="sw-status" style="color: #1976d2;">Checking...</span></p>
        </div>

        <div id="gpx-cache-status" style="margin: 15px 0; padding: 10px; background: #f3e5f5; border-radius: 4px;">
          <p style="color: #000;"><strong>GPX Routes Cached:</strong> <span id="gpx-status" style="color: #7b1fa2;">Loading...</span></p>
          <p style="font-size: 0.85em; color: #666; margin: 5px 0;">Road & Connector routes auto-cached on install</p>
        </div>

        <div id="storage-info" style="margin: 15px 0;">
          <p><strong>Map Tiles Cached:</strong> <span id="storage" style="font-weight: bold;">0</span> tiles</p>
          <p id="storage-size" style="color: #666; font-size: 0.9em;"></p>
        </div>

        <div id="tile-controls" style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 4px;">
          <p style="color: #000;"><strong>Download Map Tiles</strong></p>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
            Select a zoom level and click "Download" to cache tiles for offline use.
          </p>
          <div style="margin-bottom: 10px;">
            <label for="zoom-level" style="color: #000;">Zoom Level (11-15):</label><br>
            <input type="range" id="zoom-level" min="11" max="15" value="13" style="width: 100%;">
            <span id="zoom-value">13</span>
          </div>
          <button id="download-tiles-btn" class="button" style="width: 48%; margin-right: 4%;">
            <i class="fa fa-download"></i> Download
          </button>
          <button id="clear-tiles-btn" class="button" style="width: 48%; background: #d32f2f;">
            <i class="fa fa-trash"></i> Clear
          </button>
        </div>

        <div id="gravel-controls" style="margin: 15px 0; padding: 10px; background: #fff3e0; border-radius: 4px;">
          <p style="color: #000;"><strong>Download Routes by Category</strong></p>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
            Road & connector routes auto-cache on install. Download additional routes as needed.
          </p>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
            <button id="cache-gravel-btn" class="button" style="background: #8bc34a; font-size: 0.85em; padding: 8px;">
              <i class="fa fa-download"></i> Gravel (~200)
            </button>
            <button id="cache-recon-btn" class="button" style="background: #ffc107; font-size: 0.85em; padding: 8px;">
              <i class="fa fa-download"></i> Recon (~90)
            </button>
          </div>
          
          <button id="cache-all-gpx-btn" class="button" style="width: 100%; background: #ff6f00;">
            <i class="fa fa-download"></i> Download All Routes (~500 files)
          </button>
          
          <div id="gpx-progress-wrapper" style="display: none; margin-top: 10px;">
            <div style="font-size: 0.9em; margin-bottom: 10px;">
              <span id="gpx-progress-text">Caching routes...</span>
              <span id="gpx-progress-count" style="float: right;">0/0</span>
            </div>
            <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden;">
              <div id="gpx-progressbar" style="
                background: #ff6f00;
                height: 20px;
                width: 0%;
                transition: width 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 0.75em;
                font-weight: bold;
              "></div>
            </div>
          </div>
        </div>

        <div id="sync-controls" style="margin: 15px 0; padding: 10px; background: #e8f5e9; border-radius: 4px;">
          <p style="color: #000;"><strong>Sync Routes</strong></p>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
            After running build.py, sync to add new routes and remove deleted ones.
          </p>
          <div id="sync-status" style="font-size: 0.85em; color: #666; margin-bottom: 10px; display: none;">
            <span id="sync-status-text"></span>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <button id="check-sync-btn" class="button" style="background: #2196f3; font-size: 0.85em; padding: 8px;">
              <i class="fa fa-search"></i> Check Updates
            </button>
            <button id="sync-gpx-btn" class="button" style="background: #4caf50; font-size: 0.85em; padding: 8px;">
              <i class="fa fa-refresh"></i> Sync Now
            </button>
          </div>
          <div id="sync-details" style="display: none; margin-top: 10px; font-size: 0.8em; max-height: 150px; overflow-y: auto;">
          </div>
        </div>

        <div id="progress-wrapper" class="collapse pb-2" style="display: none; margin: 15px 0;">
          <div>
            <div style="font-size: 0.9em; margin-bottom: 10px;">
              <span id="progress-text">Downloading...</span>
              <span id="progress-count" style="float: right;">0/0</span>
            </div>
            <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden;">
              <div id="progressbar" style="
                background: #4CAF50;
                height: 20px;
                width: 0%;
                transition: width 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 0.75em;
                font-weight: bold;
              "></div>
            </div>
          </div>
        </div>

        <div id="offline-info" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
          <p><strong>How it works:</strong></p>
          <ul style="font-size: 0.85em; padding-left: 20px">
            <li>All road & connector routes auto-cache when Service Worker installs (~30 MB)</li>
            <li>Gravel & recon routes can be cached on-demand to save space</li>
            <li>Map tiles can be downloaded at specific zoom levels</li>
            <li>The app works offline once data is cached</li>
            <li>Each browser/device needs separate caching</li>
          </ul>
        </div>
    </div>

    <div class="leaflet-sidebar-pane" id="info">
      <h4>What is this site?</h4>
      <p>This site is a personal project of Joel Barrette, designed to help with route planning for bikepacking/gravel biking adventures. In it's current state it's being manually maintained as a kind of blog for all past trips as well as planned future trips. Some routes from other riders trip reports have been included but links to their posts are in the description if you want a full GPX or to read more about the specifc trip.
      </p>
    <!--<iframe src="https://docs.google.com/forms/d/e/1FAIpQLSeZM7uY1za4ZezMpsTQAfLDxXHZC8ewStKIBlW07lp4h-FCLw/viewform?embedded=true" width="100%" height="1000px" frameborder="0" marginheight="0" marginwidth="0">Loadingâ€¦</iframe>-->    
      </div>
    </div>
  </div>

  <div id="fullpage" onclick="this.style.display='none';"></div>
  
<style>

	
</style>


<script>
// Offline Mode Indicator
function updateOfflineStatus() {
  const offlineIndicator = document.getElementById('offline-indicator');
  const isOnline = navigator.onLine;
  
  if (isOnline) {
    offlineIndicator.style.display = 'none';
    document.body.style.paddingTop = '0';
  } else {
    offlineIndicator.style.display = 'block';
    document.body.style.paddingTop = '50px';
  }
}

// Check offline status on load and when connection changes
window.addEventListener('online', updateOfflineStatus);
window.addEventListener('offline', updateOfflineStatus);
window.addEventListener('load', updateOfflineStatus);

// Service Worker Registration
let swRegistration = null;
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        swRegistration = registration;
        console.log('[App] Service Worker registered:', registration);
        updateServiceWorkerStatus(); // Update status after registration
        
        // Check if this is a fresh install (no controller yet)
        // If so, reload once SW is activated to enable offline caching
        if (!navigator.serviceWorker.controller) {
          console.log('[App] First visit - waiting for SW to activate...');
          
          // Listen for the SW to become active
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'activated') {
                console.log('[App] SW activated - reloading for offline support...');
                // Show a brief message before reload
                showOfflineReadyBanner();
              }
            });
          });
        }
        
        // Check for updates periodically
        setInterval(() => {
          registration.update();
        }, 60000); // Check every minute
        
        // Listen for updates (when SW is already controlling the page)
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New service worker ready, show update notification
              console.log('[App] Update available');
              // You can add a UI notification here
            }
          });
        });
      })
      .catch((err) => {
        console.error('[App] Service Worker registration failed:', err);
        updateServiceWorkerStatus(); // Update status even on failure
      });
  });
}

// Show banner and auto-reload for offline support
function showOfflineReadyBanner() {
  const banner = document.createElement('div');
  banner.id = 'offline-ready-banner';
  banner.innerHTML = `
    <div style="
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      padding: 15px 20px;
      text-align: center;
      font-weight: bold;
      z-index: 10000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    ">
      âœ“ Offline mode ready! Reloading to enable...
    </div>
  `;
  document.body.appendChild(banner);
  
  // Reload after a brief delay so user sees the message
  setTimeout(() => {
    window.location.reload();
  }, 1500);
}
</script>






<script>
$(document).ready(function() {  
  $('#map').css('height', window.innerHeight);
  //Map Color Variables
});

$( window ).resize(function() {
  $('#map').css('height', window.innerHeight);
});

  //Initializing the Map
  var mappos = L.Permalink.getMapLocation();
  var opts = {
      map: {
        center: mappos.center,
        zoom: mappos.zoom,
        mapTypeId: 'topo',
        fullscreenControl: false,
        zoomControl: false,
        searchControl: true,
        loadingControl: true,
        disableDefaultUI: true,
        pegmanControl: false,
        scrollWheelZoom: false, // disable original zoom function
        smoothWheelZoom: true,  // enable smooth zoom 
        smoothSensitivity: 1,   // zoom speed. default is 1
      },
      points: {
        icon: {
          iconUrl: 'pin-icon-wpt.png',
          iconSize: [120, 120],
        },
      },
      elevation: {
        theme: "custom-theme",
        detachedView: true,
        elevationDiv: '#elevation-div',
        followPositionMarker: true,
        zFollow: 15,
        legend: false,
      },
      locate: {
        flyTo: true,
        position: "bottomright",
        keepCurrentZoomLevel: true,
        setView: "always"
      }
    };

	var map = L.map('map', opts.map);
  L.Permalink.setup(map);

  /*var tiles = L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
		maxZoom: 18,
		attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
			'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
		id: 'mapbox/dark-v10',
		tileSize: 512,
    edgeBufferTiles: 2,
		zoomOffset: -1
	}).addTo(map);*/

  var myRenderer = L.canvas({ padding: 0.5, tolerance: 15 });
  var lc = L.control.locate(opts.locate).addTo(map);

  //Loading GPX from JSON


  function loadGPX(fileList) {
    console.log("---- Loading GPX via JSON ----")
    for (i in fileList){
      console.log(encodeURI(fileList[i].path))
      switch (fileList[i].type){
        case "0-route":
          plotGPX(encodeURI(fileList[i].path), routeColor, " ", 5);
          break;
        case "1-road":
          plotGPX(encodeURI(fileList[i].path), roadColor, " ", 2);
          break;
        case "2-connector":
          plotGPX(encodeURI(fileList[i].path), connectorColor, " ", 2);
          break;
        case "3-gravel":
          plotGPX(encodeURI(fileList[i].path), gravelColor, " ", 2);
          break;
        case "4-recon":
          plotGPX(encodeURI(fileList[i].path), reconColor, "10 5", 2);
          break;
        case "5-caution":
          plotGPX(encodeURI(fileList[i].path), cautionColor, " ", 2);
          break;
        } 

    
    }

}
 

  function plotGPX(path, color, style, thickness) {

  //console.log(gpxList[i])
    var gpx = new L.GPX(path, {
        async: true,
        polyline_options: {
            color: color,
            opacity: 1,
            weight: thickness,
            dashArray: style,
            lineCap: 'round',
            renderer: myRenderer 
        }
    } 
        //async: true
    
    //).on('loaded', function(e) {
    //    map.fitBounds(e.target.getBounds());
    //}
    ).addTo(map);

    gpx.on('mouseover', function(e) {
        var gpx2 = e.target,
            name = gpx2.get_name()
        gpx2.setStyle({
            weight: 6
        });

        var popLocation = e.latlng;
        var popup = L.popup()
            .setLatLng(popLocation)
            .setContent(name)
            .openOn(map);
    });

    //Callback function for when plot lines are selected
    gpx.on('click', function(e) {
                
                var gpx2 = e.target;
                var converter = new showdown.Converter() // Instantiate Showdown Markdown converter
                var mdFilePath = e.target._gpx.substring(0, e.target._gpx.length-3) + "md" // Generate markdown file name hack 

                $.get( mdFilePath , function( result ){
                  console.log("Markdown entry found for " + e.target.get_name());
                  el.clear();
                  sidebar.open('sidebar-info');
                  document.getElementById("sidebar-content").innerHTML = "<h4>" + gpx2.get_name(); + "</h4>";
                  document.getElementById("sidebar-content").innerHTML += converter.makeHtml(result);
                  document.getElementById("sidebar-content").innerHTML += '<a href="' + e.target._gpx + ' ">Download GPX</a>'
                  var g = new L.GPX(e.target._gpx, {async: true});
                  g.addTo(map);
                  g.on("addline", function(e) {
                    el.addData(e.line);
                  });

                  const imgs = document.querySelectorAll('#sidebar-content > p > img');
                  const fullPage = document.querySelector('#fullpage');

                  imgs.forEach(img => {
                    img.addEventListener('click', function() {
                      fullPage.style.backgroundImage = 'url(' + img.src + ')';
                      fullPage.style.display = 'block';
                    });
                  });

                }).fail((function(){ 
                  console.log("No Markdown entry found for " + e.target.get_name());
                  el.clear();
                  sidebar.open('sidebar-info');
                  document.getElementById("sidebar-content").innerHTML = "<h4>" + gpx2.get_name(); + "</h4>";
                  document.getElementById("sidebar-content").innerHTML += "<p>No Info</p>"
                  document.getElementById("sidebar-content").innerHTML += '<a href="' + e.target._gpx + ' ">Download GPX</a>'
                  console.log(e.target._gpx);
                  var g = new L.GPX(e.target._gpx, {async: true});
                  g.addTo(map);
                  g.on("addline", function(e) {
                    el.addData(e.line);
                  });                  
                  const imgs = document.querySelectorAll('#sidebar-content > p > img');
                  const fullPage = document.querySelector('#fullpage');

                  imgs.forEach(img => {
                    img.addEventListener('click', function() {
                      fullPage.style.backgroundImage = 'url(' + img.src + ')';
                      fullPage.style.display = 'block';
                    });
                  });  
                
                })
                
                );
                
                //Stops the map layer from also receiving a click request
                L.DomEvent.stopPropagation(e);
                
                
                
                gpx2.setStyle({
                    weight: 5
                });
                
                console.log(encodeURIComponent(gpx2.get_name()))
                
                //window.location.hash = ('!' + encodeURIComponent(gpx2.get_name()));
                var pageUrl = window.location.protocol + "//" + window.location.host + window.location.search + "#!" + encodeURIComponent(gpx2.get_name())
                window.history.replaceState({path:pageUrl}, '', pageUrl);
                //document.getElementById("info-card").style.visibility = "visible";
                
                
                
                


                gpx2.setStyle({
                    weight: 3
                });
            });

	          gpx.on('mouseout', function(e) {
              //el.clear();
            map.closePopup();
            var gpx2 = e.target
            gpx2.setStyle({
                          weight: thickness
                      });
          });

        

    }





   



    map.on('click', function(e){
        sidebar.close();
        el.clear();
        console.log(window.location.hash);
        window.location.hash = '';
        var pageUrl = window.location.protocol + "//" + window.location.host + window.location.search 
        window.history.replaceState({path:pageUrl}, '', pageUrl);
    })



	
	





var el = L.control.elevation({
  	//position: "topright",
	  theme: "custom-theme", //default: lime-theme
    autofitBounds: false,
    width: 400,
    height: 200,
	  margins: {
		top: 10,
		right: 20,
		bottom: 30,
		left: 50
	},
  xTicks:4,
  followMarker: false,
  almostOver: true,
  slope: "summary",
  summary: false,

  closeBtn:false,

	useHeightIndicator: true, //if false a marker is drawn at map position
	interpolation: d3.curveLinear, //see https://github.com/d3/d3-shape/blob/master/README.md#area_curve
	hoverNumber: {
		decimalsX: 2, //decimals on distance (always in km)
		decimalsY: 0, //deciamls on hehttps://www.npmjs.com/package/leaflet.coordinatesight (always in m)
		formatter: undefined //custom formatter function may be injected
	},
	//xTicks: 4, //number of ticks in x axis, calculated by default according to width
	yTicks: 2, //number of ticks on y axis, calculated by default according to height
	collapsed: false,  //collapsed mode, show chart on click or mouseover
	imperial: false    //display imperial units instead of metric
});

el.addTo(map);

	// Custom Summary info
  el.on('eledata_added', ({layer, name, track_info}) => {

			let q = document.querySelector.bind(document);
			q('.totlen .summaryvalue').innerHTML = track_info.distance.toFixed(2) + " km";
			q('.maxele .summaryvalue').innerHTML = track_info.elevation_max.toFixed(2) + " m";
			q('.minele .summaryvalue').innerHTML = track_info.elevation_min.toFixed(2) + " m";
			q('.gain .summaryvalue').innerHTML   = "+" + track_info.ascent.toFixed(0) + " m";
			q('.loss .summaryvalue').innerHTML   = "-" + track_info.descent.toFixed(0) + " m";
		});


L.control.legend({
    position: "topright",
    legends: [{
                label: "Road",
                type: "polyline",
                color: roadColor,
                fillColor: roadColor,
                weight: 2,
                
            },{
                label: "Connector",
                type: "polyline",
                color: connectorColor,
                fillColor: connectorColor,
                weight: 2,
                
            },{
                label: "Gravel",
                type: "polyline",
                color: gravelColor,
                fillColor: gravelColor,
                weight: 2,
                
            },{
                label: "Caution",
                type: "polyline",
                color: cautionColor,
                fillColor: cautionColor,
                weight: 2,
                
            },
            {
                label: "Possible Route",
                type: "polyline",
                color: reconColor,
                fillColor: reconColor,
                dashArray: [10, 5],
                weight: 2
            }
          ]
}).addTo(map);

  //Loading Data Call
  $.getJSON( "folder.json" , function( result ){
      loadGPX(result);
  });

  //
  // CONFIGURE SIDE PANEL
  //

  var sidebar = L.control.sidebar({
    autopan: true,       // whether to maintain the centered map point when opening the sidebar
    closeButton: true,    // whether t add a close button to the panes
    container: 'sidebar', // the DOM container or #ID of a predefined sidebar container that should be used
    position: 'left',     // left or right
}).addTo(map);



sidebar.addPanel({
    id: 'zoomIn',
    tab: '<i class="fa fa-plus"></i>',
    position: 'bottom' ,
    button: function (event) { map.zoomIn(); }
});

sidebar.addPanel({
    id: 'zoomOut',
    tab: '<i class="fa fa-minus"></i>',
    position: 'bottom' ,
    button: function (event) { map.zoomOut(); }
});

</script>

<script>
 

  ///////////////////////
  // POI Layer Control
  
  var bcrecGroup = L.layerGroup() 
  var recGroup = L.layerGroup().addTo(map);
  var campGroup = L.layerGroup().addTo(map);
  var foodGroup = L.layerGroup().addTo(map);
  var groceryGroup = L.layerGroup().addTo(map);
  var bikeGroup = L.layerGroup().addTo(map);
  var warningGroup = L.layerGroup().addTo(map);
  var layerGroups = {"rec": recGroup,
                     "camp": campGroup,
                     "food": foodGroup,
                     "bikeshop": bikeGroup,
                     "warning": warningGroup
                    }

// JSON Data Loads

$.getJSON( "poi.json" , function( result ){ // Loads custom poi.json and initializes all leaflet.js markers & themeing
  for(var i=0;i<result.features.length;i++){
      if (result.features[i].properties.URL != "") {
        marker = L.marker([result.features[i].properties.LATITUDE, result.features[i].properties.LONGITUDE]).bindPopup("<a href='" + result.features[i].properties.URL + "'>" + result.features[i].properties.NAME + "</a>" + "<br>" + result.features[i].properties.DESCRIPTION) 

      }else{
        marker = L.marker([result.features[i].properties.LATITUDE, result.features[i].properties.LONGITUDE]).bindPopup(result.features[i].properties.NAME + "<br>" + result.features[i].properties.DESCRIPTION) 
      }
      themeMarker(result.features[i].properties.ICON_TYPE, marker); // Function from theme.js
      layerGroups[result.features[i].properties.POI_CATEGORY].addLayer(marker);
  }
});

$.getJSON( "rec.geojson" , function( result ){ // Loads BC Gov Rec site json data and initializes all leaflet.js markers & themeing
  for(var i=0;i<result.features.length;i++){
    if (result.features[i].properties.PROJECT_TYPE == "SIT - Recreation Site"){  
      marker = L.marker([result.features[i].properties.LATITUDE, result.features[i].properties.LONGITUDE]).bindPopup(result.features[i].properties.PROJECT_NAME+ "<br>" + result.features[i].properties.SITE_DESCRIPTION)
      marker.setIcon(campIcon);
      bcrecGroup.addLayer(marker);
    }
  }
});

var jsonStyle = {
  color:"#ff0000"
}



map.on('zoomend', function (e) {
                console.log(map.getZoom());
    if (map.getZoom()>9){
      for (var key in layerGroups){
        layerGroups[key].addTo(map)
      }
    }else{
      for (var key in layerGroups){
        layerGroups[key].remove()
      }
    }

    }
  );

function layerControl(layer){
  var checkBox = document.getElementById(layer);
  var text = document.getElementById(layer);
  if (checkBox.checked == true){
    bcrecGroup.addTo(map);
  } else {
    bcrecGroup.remove();
  }
}

// Add OpenStreetMap base layer
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);



</script>

<script>
/*
const baseLayer = L.tileLayer
  .offline('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Map data {attribution.OpenStreetMap}',
    subdomains: 'abc',
  })
  .addTo(map);
*/
    console.log(localStorage.getItem('popState'));
    if(localStorage.getItem('popState') != 'shown'){
      console.log("First time visit")
      document.getElementById("disclaimer-overlay").style.display = "block";
        
    }
      

      

</script>

<script>


/*
function storageLayer(baseLayer, layerswitcher) {
  let layer;

  const getGeoJsonData = () => getStorageInfo('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw')
    .then((tiles) => getStoredTilesAsJson(baseLayer, tiles));

  const addStorageLayer = () => {
    getGeoJsonData().then((geojson) => {
      layer = L.geoJSON(geojson).bindPopup(
        (clickedLayer) => clickedLayer.feature.properties.key,
      );
      layerswitcher.addOverlay(layer, 'offline tiles');
    });
  };

  addStorageLayer();

  baseLayer.on('storagesize', (e) => {
    document.getElementById('storage').innerHTML = e.storagesize;
    console.log(e.storagesize)
    if (layer) {
      layer.clearLayers();
      getGeoJsonData().then((data) => {
        layer.addData(data);
      });
    }
  });
} 
*/

// Note: The old leaflet-offline tile saving code has been replaced by Service Worker caching
// The baseLayer and tile controls below are now commented out as the SW handles all offline caching

/*
const control = L.control.savetiles(baseLayer, {
  zoomlevels: [11, 12, 13, 14, 15], // optional zoomlevels to save, default current zoomlevel
  confirm(layer, successCallback) {
    // eslint-disable-next-line no-alert
    if (window.confirm(`Save ${layer._tilesforSave.length}`)) {
      successCallback();
    }
  },
  confirmRemoval(layer, successCallback) {
    // eslint-disable-next-line no-alert
    if (window.confirm('Remove all the tiles?')) {
      successCallback();
    }
  },
  saveText:
    '<i class="fa fa-download" aria-hidden="true" title="Save tiles"></i>',
  rmText: '<i class="fa fa-trash" aria-hidden="true"  title="Remove tiles"></i>',
});
control.addTo(map);

const layerswitcher = L.control
  .layers({
    'osm (offline)': baseLayer,
  }, null, { collapsed: false })
  .addTo(map);

storageLayer(baseLayer, layerswitcher);
*/


// Note: Old baseLayer event handlers commented out - using Service Worker instead
/*
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };};

let progress, total;
const showProgress = debounce(() => {
  document.getElementById('progressbar').style.width = `${(progress/total) * 100}%`;
  document.getElementById('progressbar').innerHTML = progress;  
  if(progress === total) {
    setTimeout(() => document.getElementById('progress-wrapper').classList.remove('show'), 1000);    
  }
}, 10);

// Old baseLayer event handlers (commented out - using Service Worker instead)
/*
baseLayer.on('savestart', (e) => {
  progress = 0;
  total = e._tilesforSave.length;
  document.getElementById('progress-wrapper').classList.add('show');  
  document.getElementById('progressbar').style.width = '0%';
});
baseLayer.on('savetileend', () => {
  progress += 1;     
  showProgress();
});
*/

// ===== OFFLINE UI HANDLERS =====

// Update Service Worker status
function updateServiceWorkerStatus() {
  const statusEl = document.getElementById('sw-status');
  if (!statusEl) return;
  
  if ('serviceWorker' in navigator) {
    // First check if we already have a registration reference
    if (swRegistration) {
      statusEl.textContent = 'âœ“ Active';
      statusEl.style.color = '#4CAF50';
      console.log('[Offline] SW status updated: Active');
      return;
    }
    
    // Otherwise query for existing registrations with timeout
    let resolved = false;
    const timeoutId = setTimeout(() => {
      if (!resolved) {
        console.warn('[Offline] SW status check timed out');
        statusEl.textContent = 'âŠ Registering...';
        statusEl.style.color = '#ff9800';
      }
    }, 3000);
    
    navigator.serviceWorker.getRegistrations()
      .then((registrations) => {
        resolved = true;
        clearTimeout(timeoutId);
        if (registrations && registrations.length > 0) {
          swRegistration = registrations[0];
          statusEl.textContent = 'âœ“ Active';
          statusEl.style.color = '#4CAF50';
          console.log('[Offline] SW status updated: Active');
        } else {
          statusEl.textContent = 'âŠ Registering...';
          statusEl.style.color = '#ff9800';
          console.log('[Offline] SW status: Registering');
        }
      })
      .catch((err) => {
        resolved = true;
        clearTimeout(timeoutId);
        console.error('[Offline] SW getRegistrations failed:', err);
        statusEl.textContent = 'âœ— Unavailable';
        statusEl.style.color = '#d32f2f';
      });
  } else {
    statusEl.textContent = 'âœ— Not supported';
    statusEl.style.color = '#d32f2f';
    console.log('[Offline] SW not supported');
  }
}

// Update GPX cache status
function updateGPXStatus() {
  const statusEl = document.getElementById('gpx-status');
  if (!statusEl) return;
  
  caches.open('bikemap-v1-2025-12-30-v10')
    .then((cache) => {
      return cache.keys()
        .then((keys) => {
          const gpxFiles = keys.filter(req => req.url.endsWith('.gpx'));
          if (gpxFiles.length > 0) {
            statusEl.textContent = `âœ“ ${gpxFiles.length} routes cached`;
            statusEl.style.color = '#4CAF50';
          } else {
            statusEl.textContent = 'â—‹ No routes cached yet';
            statusEl.style.color = '#999';
          }
        });
    })
    .catch(() => {
      statusEl.textContent = 'â—‹ Not cached yet';
      statusEl.style.color = '#999';
    });
}

// Update tile cache status
function updateTileStatus() {
  const storageEl = document.getElementById('storage');
  const storageSizeEl = document.getElementById('storage-size');
  if (!storageEl) return;
  
  caches.open('bikemap-tiles-v1')
    .then((cache) => {
      return cache.keys()
        .then((keys) => {
          const tileFiles = keys.filter(req => {
            // Match tile URL patterns
            return /\/(\d+)\/(\d+)\/(\d+)\.(png|jpg|webp)($|\?)/i.test(new URL(req.url).pathname);
          });
          
          if (tileFiles.length > 0) {
            storageEl.textContent = tileFiles.length.toLocaleString();
            
            // Optionally estimate storage size (rough estimate: ~15KB per tile)
            const estimatedMB = (tileFiles.length * 15) / 1024;
            if (storageSizeEl && estimatedMB > 0.1) {
              storageSizeEl.textContent = `~${estimatedMB.toFixed(1)} MB`;
            }
          } else {
            storageEl.textContent = '0';
            if (storageSizeEl) {
              storageSizeEl.textContent = '';
            }
          }
        });
    })
    .catch(() => {
      storageEl.textContent = '0';
      if (storageSizeEl) {
        storageSizeEl.textContent = '';
      }
    });
}

// Function to cache GPX files by category
async function cacheGPXByType(types, buttonText = 'routes') {
  const progressWrapper = document.getElementById('gpx-progress-wrapper');
  const progressBar = document.getElementById('gpx-progressbar');
  const progressText = document.getElementById('gpx-progress-text');
  const progressCount = document.getElementById('gpx-progress-count');
  
  try {
    // Show progress UI
    progressWrapper.style.display = 'block';
    progressText.textContent = `Loading ${buttonText}...`;
    progressBar.style.width = '0%';
    
    // Fetch folder.json to get all GPX files
    const response = await fetch('/folder.json');
    const allFiles = await response.json();
    
    // Filter by requested types
    const filesToCache = allFiles.filter(file => types.includes(file.type));
    
    progressCount.textContent = `0/${filesToCache.length}`;
    progressText.textContent = `Caching ${buttonText}...`;
    
    let cached = 0;
    let failed = 0;
    
    // Cache files in batches to avoid overwhelming the browser
    const batchSize = 5;
    for (let i = 0; i < filesToCache.length; i += batchSize) {
      const batch = filesToCache.slice(i, i + batchSize);
      
      await Promise.allSettled(
        batch.map(file => {
          // Use encodeURI to match how files are loaded by plotGPX
          const encodedPath = encodeURI(file.path);
          return fetch(encodedPath)
            .then(res => {
              if (res.ok) {
                cached++;
                return caches.open('bikemap-v1-2025-12-30-v8').then(cache => cache.put(encodedPath, res));
              } else {
                failed++;
                return Promise.reject();
              }
            })
            .catch(() => {
              failed++;
            });
        })
      );
      
      // Update progress
      const totalProcessed = Math.min(i + batchSize, filesToCache.length);
      const percent = (totalProcessed / filesToCache.length) * 100;
      progressBar.style.width = `${percent}%`;
      progressBar.textContent = `${Math.round(percent)}%`;
      progressCount.textContent = `${totalProcessed}/${filesToCache.length}`;
    }
    
    // Done
    progressText.textContent = `âœ“ Complete! ${cached} cached, ${failed} failed`;
    progressBar.style.background = '#4CAF50';
    
    setTimeout(() => {
      progressWrapper.style.display = 'none';
      progressBar.style.background = '#ff6f00';
      updateGPXStatus();
    }, 3000);
    
  } catch (err) {
    console.error('[Offline] Error caching GPX files:', err);
    progressText.textContent = 'âœ— Error: ' + err.message;
    progressBar.style.background = '#d32f2f';
  }
}

// Helper to communicate with service worker
function sendMessageToSW(message) {
  return new Promise((resolve, reject) => {
    if (!navigator.serviceWorker.controller) {
      reject(new Error('No service worker controller'));
      return;
    }
    
    const messageChannel = new MessageChannel();
    messageChannel.port1.onmessage = (event) => {
      if (event.data.success) {
        resolve(event.data);
      } else {
        reject(new Error(event.data.error || 'Unknown error'));
      }
    };
    
    navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
  });
}

// Check for sync updates
async function checkSyncStatus() {
  const statusDiv = document.getElementById('sync-status');
  const statusText = document.getElementById('sync-status-text');
  const detailsDiv = document.getElementById('sync-details');
  
  statusDiv.style.display = 'block';
  statusText.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Checking...';
  detailsDiv.style.display = 'none';
  
  try {
    const status = await sendMessageToSW({ type: 'GET_SYNC_STATUS', types: ['0-route', '1-road', '2-connector', '3-gravel', '4-recon', '5-caution', 'routes'] });
    
    if (status.toAdd === 0 && status.toRemove === 0) {
      statusText.innerHTML = 'âœ“ <span style="color: #4caf50;">Cache is up to date!</span>';
      detailsDiv.style.display = 'none';
    } else {
      statusText.innerHTML = `<span style="color: #ff9800;">Updates available:</span> +${status.toAdd} new, -${status.toRemove} removed`;
      
      // Show details
      let detailsHtml = '';
      if (status.newFiles.length > 0) {
        detailsHtml += '<div style="color: #4caf50; margin-bottom: 5px;"><strong>New:</strong></div>';
        detailsHtml += '<ul style="margin: 0 0 10px 15px; padding: 0;">';
        status.newFiles.slice(0, 10).forEach(f => {
          detailsHtml += `<li style="color: #4caf50;">${f}</li>`;
        });
        if (status.newFiles.length > 10) {
          detailsHtml += `<li style="color: #666;">...and ${status.newFiles.length - 10} more</li>`;
        }
        detailsHtml += '</ul>';
      }
      if (status.removedFiles.length > 0) {
        detailsHtml += '<div style="color: #d32f2f; margin-bottom: 5px;"><strong>Removed:</strong></div>';
        detailsHtml += '<ul style="margin: 0 0 10px 15px; padding: 0;">';
        status.removedFiles.slice(0, 10).forEach(f => {
          detailsHtml += `<li style="color: #d32f2f;">${f}</li>`;
        });
        if (status.removedFiles.length > 10) {
          detailsHtml += `<li style="color: #666;">...and ${status.removedFiles.length - 10} more</li>`;
        }
        detailsHtml += '</ul>';
      }
      detailsDiv.innerHTML = detailsHtml;
      detailsDiv.style.display = 'block';
    }
  } catch (err) {
    statusText.innerHTML = `<span style="color: #d32f2f;">âœ— Error: ${err.message}</span>`;
    console.error('[Sync] Check failed:', err);
  }
}

// Perform sync
async function performSync() {
  const statusDiv = document.getElementById('sync-status');
  const statusText = document.getElementById('sync-status-text');
  const detailsDiv = document.getElementById('sync-details');
  const syncBtn = document.getElementById('sync-gpx-btn');
  
  statusDiv.style.display = 'block';
  statusText.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Syncing...';
  detailsDiv.style.display = 'none';
  syncBtn.disabled = true;
  
  try {
    const result = await sendMessageToSW({ type: 'SYNC_GPX', types: ['0-route', '1-road', '2-connector', '3-gravel', '4-recon', '5-caution', 'routes'] });
    
    statusText.innerHTML = `<span style="color: #4caf50;">âœ“ Sync complete!</span> Added: ${result.added}, Removed: ${result.removed}`;
    
    // Refresh GPX status
    updateGPXStatus();
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      statusDiv.style.display = 'none';
    }, 5000);
    
  } catch (err) {
    statusText.innerHTML = `<span style="color: #d32f2f;">âœ— Sync failed: ${err.message}</span>`;
    console.error('[Sync] Failed:', err);
  } finally {
    syncBtn.disabled = false;
  }
}

// Button handlers
document.addEventListener('DOMContentLoaded', () => {
  // Cache all routes button
  const cacheAllBtn = document.getElementById('cache-all-gpx-btn');
  if (cacheAllBtn) {
    cacheAllBtn.addEventListener('click', () => {
      cacheGPXByType(['0-route', '1-road', '2-connector', '3-gravel', '4-recon', '5-caution', 'routes'], 'all routes');
    });
  }
  
  // Cache gravel routes button
  const cacheGravelBtn = document.getElementById('cache-gravel-btn');
  if (cacheGravelBtn) {
    cacheGravelBtn.addEventListener('click', () => {
      cacheGPXByType(['3-gravel'], 'gravel routes');
    });
  }
  
  // Cache recon routes button
  const cacheReconBtn = document.getElementById('cache-recon-btn');
  if (cacheReconBtn) {
    cacheReconBtn.addEventListener('click', () => {
      cacheGPXByType(['4-recon'], 'recon routes');
    });
  }
  
  // Check sync button
  const checkSyncBtn = document.getElementById('check-sync-btn');
  if (checkSyncBtn) {
    checkSyncBtn.addEventListener('click', checkSyncStatus);
  }
  
  // Sync now button
  const syncGpxBtn = document.getElementById('sync-gpx-btn');
  if (syncGpxBtn) {
    syncGpxBtn.addEventListener('click', performSync);
  }
});


    
   




// Update displays on load
window.addEventListener('load', () => {
  // Service worker status will be updated after registration completes
  // (called in the registration .then() handler)
  
  updateGPXStatus();
  updateTileStatus();
  
  // Update tile status every 5 seconds (tiles are cached as map is panned)
  setInterval(updateTileStatus, 5000);
  
  // Update GPX status every 10 seconds
  setInterval(updateGPXStatus, 10000);
});

// Old baseLayer event handlers (commented out - using Service Worker instead)
/*
// Update storage when tiles are saved
if (typeof baseLayer !== 'undefined' && baseLayer.on) {
  baseLayer.on('saveend', () => {
    console.log('[Offline] Save complete');
    document.getElementById('progress-wrapper').style.display = 'none';
    updateStorageDisplay();
  });
  
  baseLayer.on('savetileend', () => {
    const count = document.getElementById('progress-count');
    if (count && count.textContent) {
      const [current, total] = count.textContent.split('/').map(Number);
      count.textContent = `${current + 1}/${total}`;
    }
  });
}
*/

</script>

</body>
</html>